字符编码
	ASCII--由于计算机是美国人发明的，最早有127个字符被编到计算机里，也就是大小写英文字母、数字、一些符号。大写A编码65，小写z编码122
	GB2312--由于中文用一个字节是不够的，至少需要两个字节，而且还不能与ASCII冲突，中国就制定了GB2312编码，用来把中文编进去。
	
	世界上有百种语言，各个国家都有各自的标准。这样各个国家标准不可避免的会出现冲突，结果在多语言编写的文本中，显示会有乱码。
	因此Unicode应运而生，他把所有的语言统一到一套编码里。这样就不会出现乱码了。这个标准最常用的是两个字节表示一个字符。现代操作系统和大多数编程语言都支持Unicode。

	这样的话又出现一个问题 ，若文本基本上都是英文的，用unicode编码比ASCII编码更需要多一倍的存储空间，在存储和传输上就不划算。这时UTF-8编码出现了，他可以把一个unicode字符
	根据数字大小编码成1-6个字节，英文通常1个字节，中文通常3个字节，生僻的字符通常4-6个字节。若传输的文件包括大量英文字符，使用UTF-8就能节省空间

	计算机系统通用的字符编码工作方式
		在计算机内存中，统一使用unicode编码，当需要保存到硬盘或传输的时候，就转换为UTF-8编码
		用记事本编辑时，从文件读取的UTF-8被转换为unicode字符到内存中，编辑完保存时再把unicode转化为UTF-8保存到文件中
		浏览网页时，服务器会把动态生成的unicode内容转化为UTF-8再传输到浏览器。所以能看到网页的源码上会有类似<meta charset="UTF-8"  />的信息，表示该网页正在使用UTF-8编码
Python的字符串
	在最新的Python 3版本中，字符串是以unicode编码的，他是支持多语言的。
	对于单个字符的编码，他提供了 ord()--获取字符的整数表示，chr()--将编码值转化为字符，len()--获取字符的长度
	在网络上传输或者保存到磁盘上，需要把字符串str变为以字节为单位的bytes，使用b前缀的单引号或双引号表示 x=b'abc'

	1 以unicode表示的字符串str通过encode()方法可以编码为指定的bytes。例如
		'ABC'.encode('ascii')
		'中文'.encode('utf-8')  注意中文是不能使用ascii编码的，因为中文编码范围超出了ascii的编码范围。
		在bytes中无法显示为ascii字符的字节，使用\x##显示
	2 反过来 我们从网络或者磁盘上读取了字节流，那么可以读到的数据就是bytes，要把bytes变成str，就需要deconde()，例如：
		>>> b'ABC'.decode('ascii')
		'ABC'
		>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
		'中文'
	如果bytes中有一小部分包含无效的字节，可以传入errors='ignore'忽略错误的字节
		>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
		'中'
	len("abc")
	len("中文")

	在读取源代码时，为了让他按照utf-8编码读取，在文件的开头写上 
		#！/usr/bin/env python3  
		# -*- conding:utf-8 -*-
	第一行注释是为了告诉Linux/os x系统，这是python可执行的程序，windows系统会忽略这个注释
	第二行为了告诉python解释器，按照utf-8编码读取源码，否则你在源码中写的中文输出会有乱码。声明了Utf-8编码不代表文件就是utf-8编码，必须将文件保存为utf-8 withot bom编码
格式化
	Python和c格式一致，使用%实现，例如：
	>>>'hello ,%s' % 'world'
	>>>'hi,%s,you have $%d.' % ('michael',1000)
	常见的占位符：%s %d %f %x.如果字符串里面的%是一个普通的字符怎么办？这个时候就需要转义，用%%来表示一个%:
	>>>'growth rate:%d %%' % 7

